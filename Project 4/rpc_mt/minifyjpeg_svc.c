/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "minifyjpeg.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include <getopt.h>
#include <sys/syscall.h>
#include <pthread.h>
#include <fcntl.h>
#include <errno.h>
#include "magickminify.h"

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif


#define USAGE                                                                 \
"usage:\n"                                                                    \
"  minifyjpeg [options]\n"                                                 \
"options:\n"                                                                  \
"  -t [nthreads]       Number of threads (Default: 8)\n"                      \
"  -h                  Show this help message.\n"                             \

void *MinifyWorker(void* );

/* OPTIONS DESCRIPTOR ====================================================== */
static struct option gLongOptions[] = {
  {"thread-count",  required_argument,      NULL,           't'},         
  {"help",          no_argument,            NULL,           'h'},
  {NULL,            0,                      NULL,            0}
};

int
_minify_jpeg_proc_1 (JPEG_IN  *argp, xdrproc_t *xdrArg, struct svc_req *rqstp, SVCXPRT *transp)
{
	return (minify_jpeg_proc_1_svc(*argp, xdrArg, rqstp, transp));
}

///
/// SVC_Registered function is our BOSS Thread
//	Pushes the SVC_Request and Transport info in to a queue and signals a thread to handle and
//  goes back to accept new requests right away
///
static void
minify_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		JPEG_IN minify_jpeg_proc_1_arg;
	} argument;

	bool_t retval;
	xdrproc_t _xdr_argument;//, _xdr_result;
	bool_t (*local)(char *, xdrproc_t *, struct svc_req *, SVCXPRT *);

	switch (rqstp->rq_proc)
	{
		case NULLPROC:
			(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
			exit(1);

		case MINIFY_JPEG_PROC:
			_xdr_argument = (xdrproc_t) xdr_JPEG_IN;
			local = (bool_t (*) (char *, xdrproc_t *, struct svc_req *, SVCXPRT *))_minify_jpeg_proc_1;
			break;

		default:
			svcerr_noproc (transp);
			exit (1);
	}

	memset ((char *)&argument, 0, sizeof (argument));

	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) 
	{
		perror("svc_getargs FAILED !! ");
		svcerr_decode (transp);
		exit(1);
	}

	retval = (bool_t) (*local)((char *)&argument, &_xdr_argument, rqstp, transp);
	if(retval > 0 )
	{
		perror("minify call failed");
	}

	return;
}

int
main (int argc, char **argv)
{
	register SVCXPRT *transp;
	int nThreads = 1 ;
	int option_char = 0;

	while ((option_char = getopt_long(argc, argv, "ic:ht:x", gLongOptions, NULL)) != -1) {
		switch (option_char) {
			default:
		        fprintf(stderr, "%s", USAGE);
		        exit(1);
			case 'h': // help
				fprintf(stdout, "%s", USAGE);
				exit(0);
			case 't': // thread-count
				nThreads = atoi(optarg);
				break;
		}
	}

	pmap_unset (MINIFY_PROG, MINIFY_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, MINIFY_PROG, MINIFY_VERS, minify_prog_1, IPPROTO_UDP)) {
		perror("Unable to register");
		fprintf (stderr, "%s", "unable to register (MINIFY_PROG, MINIFY_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, MINIFY_PROG, MINIFY_VERS, minify_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (MINIFY_PROG, MINIFY_VERS, tcp).");
		exit(1);
	}

	threadInfo_t threadsInfo[nThreads];
	//
	// Create the queue 
	//
	requestQueue = (steque_t*) malloc(sizeof(steque_t));
	steque_init(requestQueue);

	//Create global mutex
	g_locks  = (locks_t*) malloc(sizeof(locks_t));
	
	pthread_cond_init(&g_locks->cond, NULL);
	pthread_mutex_init(&g_locks->mutex, NULL);
	pthread_cond_init(&g_locks->fCond, NULL);
	pthread_mutex_init(&g_locks->fMutex, NULL);
	
	for(int i=0; i< nThreads; i++)
	{
		threadsInfo[i].threadState = 0;
		threadsInfo[i].IsEnabled = true;

		if (pthread_create(&threadsInfo[i].hThread, NULL, MinifyWorker, &threadsInfo[i]))
		{
			printf("Error creating thread");
		}
	}

	svc_run ();
	//Never happens but still !

	for (int i=0; i<=nThreads; i++)
	{
		threadsInfo[i].IsEnabled = true; //Signall all thread to close
		if (pthread_cond_broadcast(&g_locks->cond) != 0)
		{
			printf("Function %s Line: %d Broadcast Failed with Error %d ! \n", __FUNCTION__, __LINE__, errno);
		}
		pthread_join(threadsInfo[i].hThread, NULL);
	}

	pthread_mutex_destroy(&g_locks->mutex);
	pthread_cond_destroy(&g_locks->cond);
	pthread_mutex_destroy(&g_locks->fMutex);
	pthread_cond_destroy(&g_locks->fCond);

	//Destroy the queue
	if (requestQueue)
	{
		steque_destroy(requestQueue);
	}

	if (g_locks)
	{
		free(g_locks);
	}	
	
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}

//
//	Worker Thread Implemetation
//  Reads the queue and invokes respective PROC Procedures
//
void *MinifyWorker(void* arg)
{
  	threadInfo_t *threadInfo = (threadInfo_t*) arg;
	union {
		JPEG_OUT minify_jpeg_proc_1_res;
	} result;

	xdrproc_t _xdr_result = (xdrproc_t) xdr_JPEG_OUT;
	//This needs to be called from handler
	while(threadInfo->IsEnabled)
	{
		threadInfo->threadState = 1;
		
		//Lock the queue
		pthread_mutex_lock(&g_locks->mutex);
		#if DEBUG_LOG // 
		printf("Locked mutex TID:%d \n", syscall(SYS_gettid));
		#endif //DEBUG_LOG    

		while(steque_isempty(requestQueue))
		{
			pthread_cond_wait(&g_locks->cond, &g_locks->mutex);
		}

		#if DEBUG_LOG //
		printf("Received signal TID:%d \n", syscall(SYS_gettid));
		#endif //DEBUG_LOG
		
		//Read the queue
		minifyRequest_t *minifyRequest = (minifyRequest_t*) steque_pop(requestQueue);
		//Unlock the queue
		pthread_mutex_unlock(&g_locks->mutex);
		
		result.minify_jpeg_proc_1_res.buffer.buffer_val = (char*) magickminify(minifyRequest->jpeg_in_arg.buffer.buffer_val, minifyRequest->jpeg_in_arg.buffer.buffer_len, ((ssize_t*)&result.minify_jpeg_proc_1_res.buffer.buffer_len));
		if (result.minify_jpeg_proc_1_res.buffer.buffer_val == NULL)
		{
			perror("Failed to minify");
		}
		
		if (!svc_sendreply(minifyRequest->transp, (xdrproc_t) _xdr_result, (char *)&result)) 
		{
			svcerr_systemerr (minifyRequest->transp);
		}

		if (!minify_prog_1_freeresult (minifyRequest->transp, _xdr_result, (caddr_t) &result))
		{
			perror("minify_prog_1_freeresult failed ");
			fprintf (stderr, "%s", "unable to free results");
		}	

		if (minifyRequest)
		{
			free(minifyRequest);
		}

	}//go back & wait for boss's order

	return (void*) NULL;
}